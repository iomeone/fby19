* Motivation

* Theory
  In this section I introduce type and value level language, and talk about
  typing judgements. We then take a "break" from theory and work on
  implementation relevant definitions and the implementation itself.

* Implementation
  Implementation mixes theory and implementation. We introduce

** AST datatypes

** Substitution

   A substitution is a mapping from type variables to types.

   In maths we write a substitution that maps the variable a to Int as [a/Int].

   There are two operations involving substitutions:

   - Applying a substitution to a type
   - Composing two substitutions

*** Applying a substitution

    When applying a substitution to a type, we replace every
    occurrence of a variable that occurs in the substitution in the
    given type.

    applySubstitution [a/Int, b/Int -> Bool] (a -> b) = Int -> Int -> Bool

**** Applying a substitution to a substitution

     Once I can apply a substitution to a type I can also apply it to
     another substitution by applying it to every mapped type.

     [a/Int, b/Int -> Bool] [c/a -> b] = [c/Int -> Int -> Bool]

*** Composing substitutions

    Let S and S' be substitutions then their composition for all types
    t is defined as:

    (S âˆ˜ S') t = S (S' t)

** Unification
   Finding a substitution that makes two type equal. (To be precise, the most general one)

   Eg: a ~ b => [a/Int, b/Int], true but not general enough
       a ~ b => [a/b]


*** Free variables
    A free variable is a variable that is not bound in a Schema. Eg:

    forall a. a -> b -> a

    b is free here

    We'll never surface this kind of type to the user, it's a
    construct internal to the type checker.

*** Occurs check
    We cannot allow a variable to be substituted to a type that contains itself. (for obvious infinity reasons)

    For example, we cannot create a substitution like: [x/Int -> x]

*** Unification for our types

** Generalization/Instantiation

gen: u1 -> u2 => forall a b. a -> b
inst: forall a b. a -> b => u1 -> u2
